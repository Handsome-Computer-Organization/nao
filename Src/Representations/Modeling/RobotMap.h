/**
* @file RobotMap.h
* Declaration of a class that represents the map of tracked robots in this robot's environment.
* @author <a href="mailto:stefan.czarnetzki@tu-dortmund.de">Stefan Czarnetzki</a>
*/

#pragma once
#include "Representations/Perception/RobotsPercept.h"
#include "Tools/Streams/AutoStreamable.h"
#include "Tools/Math/Pose2f.h"
#include "Tools/Math/Pose3f.h"
#include <vector>

/**
* @class RobotMap
* A class represents the map of tracked robots in this robot's environment.
*/

STREAMABLE(RobotMapEntry,
{,
  (Pose2f) pose, /**< The position in absolute field coordinates. */
  ((RobotEstimate) RobotType)(RobotEstimate::unknownRobot) robotType,
  /** This is nice to have but might not be filled correctly and will not be sent! **/
  (Vector2f) velocity,
  (float)(0.f) validity,
});

// Global robot map (local + remote)
STREAMABLE(RobotMap,
{
  RobotMap() { robots.reserve(10); }

  /** Reset the RobotMap */
  void reset() { robots.clear(); }

  RobotMap& operator=(const RobotMap &other)
  {
    if (this == &other)
      return *this;

    reset();
    for (unsigned int i = 0; i < other.robots.size(); i++)
    {
      RobotMapEntry re;
      re.pose = other.robots[i].pose;
      re.robotType = other.robots[i].robotType;
      re.velocity = other.robots[i].velocity;
      re.validity = other.robots[i].validity;
      robots.push_back(re);
    }
    return *this;
  }

  void draw() const,
  (std::vector<RobotMapEntry>) robots, /**< The robots in absolute field coordinates. */

});


struct GroundTruthRobotMap : public RobotMap
{
  /** Draws something*/
  void draw() const;
};


// Local robot map
struct LocalRobotMap : public RobotMap
{
  void draw() const;
};


// Robot map of generated by teammate data
struct RemoteRobotMap : public RobotMap
{
  /** Draws something*/
  void draw() const;
};


STREAMABLE(RobotMapCompressedEntry,
{
  RobotMapCompressedEntry() = default;
  RobotMapCompressedEntry(const Pose2f& pose, RobotEstimate::RobotType type, float validity)
  {
    position = pose.translation.cast<short>();
    rotation = static_cast<std::uint8_t>((toDegrees(pose.rotation) + 180.f) / 360.f * std::numeric_limits<std::uint8_t>::max());
    robotType = type;
    this->validity = static_cast<std::uint8_t>(validity * 255.f);
  },

  (Vector2s) position,
  (std::uint8_t)(0) rotation,
  ((RobotEstimate) RobotType)(RobotEstimate::unknownRobot) robotType,
  (std::uint8_t)(0) validity,
});

STREAMABLE(RobotMapCompressed,
{
  RobotMapCompressed() = default;
  RobotMapCompressed(const RobotMap& other)
  {
    robots.clear();
    for (unsigned int i = 0; i < other.robots.size(); i++)
    {
      robots.push_back(RobotMapCompressedEntry(
        other.robots[i].pose,
        other.robots[i].robotType,
        other.robots[i].validity));
    }
  }

  operator RobotMap() const
  {
    RobotMap robotMap;
    robotMap.robots.clear();
    for (unsigned int i = 0; i < robots.size(); i++)
    {
      RobotMapEntry re;
      re.pose.translation = robots[i].position.cast<float>();
      re.pose.rotation = robots[i].rotation / std::numeric_limits<std::uint8_t>::max() * 360.f - 180.f;
      re.robotType = robots[i].robotType;
      re.velocity = Vector2f::Zero();
      re.validity = static_cast<float>(robots[i].validity) / 255.f;
      robotMap.robots.push_back(re);
    }
    return robotMap;
  },

  (std::vector<RobotMapCompressedEntry>) robots,

});

STREAMABLE(LocalRobotMapCompressed,
{
  LocalRobotMapCompressed() = default;
  LocalRobotMapCompressed(const LocalRobotMap& other)
  {
    robots.clear();
    for (unsigned int i = 0; i < other.robots.size(); i++)
    {
      robots.push_back(RobotMapCompressedEntry(
        other.robots[i].pose,
        other.robots[i].robotType,
        other.robots[i].validity));
    }
  }

  operator LocalRobotMap() const
  {
    LocalRobotMap robotMap;
    robotMap.robots.clear();
    for (unsigned int i = 0; i < robots.size(); i++)
    {
      RobotMapEntry re;
      re.pose.translation = robots[i].position.cast<float>();
      re.pose.rotation = robots[i].rotation / std::numeric_limits<std::uint8_t>::max() * 360.f - 180.f;
      re.robotType = robots[i].robotType;
      re.velocity = Vector2f::Zero();
      re.validity = static_cast<float>(robots[i].validity) / 255.f;
      robotMap.robots.push_back(re);
    }
    return robotMap;
  },

  (std::vector<RobotMapCompressedEntry>) robots,

});
